use Metamodel;
use Op;
use RxOp;
use CClass;
use CgOp;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaBackendHoopl;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use GetOptLong;
use NieczaActions;
use OpHelpers;
use Operator;
use OptRxSimple;
use STD;
use Stash;
use Sig;

augment grammar STD {
our $ALL;
method newlex ($needsig = 0, $once = False) {
    my $oid = $*CURLEX.id;
    my $osub = $*CURLEX<!sub>;
    $ALL.{$oid} === $*CURLEX or die "internal error: current lex id is invalid";
    my $line = self.lineof(self.pos);
    my $id;
    if $*NEWLEX {
        $*NEWLEX.<OUTER::> = $*CURLEX.idref;
        $*CURLEX = $*NEWLEX;
        $*NEWLEX = 0;
        $id = $*CURLEX.id;
    }
    else {
        $id = 'MY:file<' ~ $*FILE<name> ~ '>:line(' ~ $line ~ '):pos(' ~ self.pos ~ ')';
        $*CURLEX = Stash.new(
            'OUTER::' => [$oid],
            '!file' => $*FILE, '!line' => $line,
            '!id' => [$id],
        );
    }
    $*CURLEX.<!NEEDSIG> = 1 if $needsig;
    $*CURLEX.<!IN_DECL> = $*IN_DECL if $*IN_DECL;
    $ALL.{$id} = $*CURLEX;
    $*CURLEX<!sub> = ::Metamodel::StaticSub.new(
        unit => $*unit,
        class => 'Block',
        outerx => $osub.xref,
        in_class => $osub.in_class,
        cur_pkg => $osub.cur_pkg,
        run_once => $once && $osub.run_once
    );
    $osub.add_child($*CURLEX<!sub>);
    self;
}
token embeddedblock {
    # encapsulate braided languages
    :temp %*LANG;
    :my $*SIGNUM;
    :my $*GOAL ::= '}';
    :temp $*CURLEX;

    :dba('embedded block')

    '{' ::
    <.newlex>
    <.finishlex>
    [ :lang(%*LANG<MAIN>) <statementlist> ]
    [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
}
method explain_mystery() {
    my %post_types;
    my %unk_types;
    my %unk_routines;
    my $m = '';
    for keys(%*MYSTERY) {
        my $p = %*MYSTERY{$_}.<lex>;
        if self.is_name($_, $p) {
            # types may not be post-declared
            %post_types{$_} = %*MYSTERY{$_};
            next;
        }

        next if self.is_known($_, $p) or self.is_known('&' ~ $_, $p);

        # just a guess, but good enough to improve error reporting
        if $_ lt 'a' {
            %unk_types{$_} = %*MYSTERY{$_};
        }
        else {
            %unk_routines{$_} = %*MYSTERY{$_};
        }
    }
    if %post_types {
        my @tmp = sort keys(%post_types);
        $m ~= "Illegally post-declared type" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %post_types{$_}.<line> ~ "\n";
        }
    }
    if %unk_types {
        my @tmp = sort keys(%unk_types);
        $m ~= "Undeclared name" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %unk_types{$_}.<line> ~ "\n";
        }
    }
    if %unk_routines {
        my @tmp = sort keys(%unk_routines);
        $m ~= "Undeclared routine" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %unk_routines{$_}.<line> ~ "\n";
        }
    }
    self.sorry($m) if $m;

    for $*unit.stubbed_stashes {
        next if .key.closed;
        .value.sorry("Package was stubbed but not defined");
    }

    self;
}

method getsig {
    my $pv = $*CURLEX.{'%?PLACEHOLDERS'};
    state %method = (:Method, :Submethod, :Regex);
    if $*CURLEX.<!NEEDSIG>:delete {
        my @parms;
        if %method{$*CURLEX<!sub>.class} {
            my $cl = $*CURLEX<!sub>.methodof &&
                $*unit.deref($*CURLEX<!sub>.methodof);
            # XXX type checking against roles NYI
            if $cl && $cl !~~ ::Metamodel::Role &&
                    $cl !~~ ::Metamodel::ParametricRole {
                push @parms, ::Sig::Parameter.new(name => 'self', :invocant,
                    tclass => $cl.xref);
            } else {
                push @parms, ::Sig::Parameter.new(name => 'self', :invocant);
            }
            $*CURLEX<!sub>.add_my_name('self', :noinit);
        }

        if $pv {
            my $h_ = $pv.<%_>:delete;
            my $a_ = $pv.<@_>:delete;
            for (keys %$pv).sort({ substr($^a,1) leg substr($^b,1) }) -> $pn is copy {
                my $positional = True;
                if substr($pn,0,1) eq ':' {
                    $pn = substr($pn,1);
                    $positional = False;
                }
                my $list = substr($pn,0,1) eq '@';
                my $hash = substr($pn,0,1) eq '%';
                push @parms, ::Sig::Parameter.new(slot => $pn, :$list, :$hash,
                    name => $pn, :$positional, names => [ substr($pn,1) ]);
                $*CURLEX<!sub>.add_my_name($pn, :noinit, :$list, :$hash);
            }
            if $a_ {
                push @parms, ::Sig::Parameter.new(slot => '@_', name => '*@_',
                    :slurpy, :list);
                $*CURLEX<!sub>.add_my_name('@_', :noinit, :list);
            }
            if $h_ {
                push @parms, ::Sig::Parameter.new(slot => '%_', name => '*%_',
                    :slurpy, :hash);
                $*CURLEX<!sub>.add_my_name('%_', :noinit, :hash);
            }
        }
        else {
            push @parms, ::Sig::Parameter.new(name => '$_', slot => '$_',
                :defouter, :rwtrans);
            $*CURLEX<!sub>.add_my_name('$_', :noinit);
        }
        $*CURLEX<!sub>.signature = ::GLOBAL::Sig.new(params => @parms);
    }
    # NIECZA immutable cursors
    # self.<sig> = $sig;
    # self.<lex> = $*CURLEX.idref;
    if ($*DECLARAND<mult>//'') ne 'proto' {
        for keys %$*CURLEX {
            my $desc = $*CURLEX{$_};
            next if $_ eq '$_' or $_ eq '@_' or $_ eq '%_';
            next if $desc !~~ Hash;
            next if $desc<used>;
            next if $desc<rebind>;
            next if $desc<dynamic>;
            next if $desc<scope> eq 'our';
            next if $desc<scope> eq 'state';
            next if $desc<stub>;
            next unless $_ ~~ /<[\$\@\%\&]>\w/;
            my $pos = $desc<declaredat> // self.pos;
            self.cursor($pos).worry("$_ is declared but not used");
        }
    }
    self;
}

}

augment grammar STD::P6 { #OK
    token regex_def_1($*cursor) { <?> }
    token regex_def_2($*cursor) { <?> }
    rule regex_def ($d, :$r, :$s) {
        :temp $*CURLEX;
        :my $*IN_DECL = $d;
        :temp %*RX;
        :my $*DECLARAND;
        :my $*HAS_SELF = 'complete';
        { %*RX<s> = $s; %*RX<r> = $r; }
        [
            [ '&'<deflongname>? | <deflongname> ]?
            {
                given $*PKGDECL {
                    when 'grammar' {} # XXX to be replaced by MOP queries
                    when 'role'    {}
                    default { $¢.worry("'$d' declaration outside of grammar") if ($*SCOPE || 'has') eq 'has' && $<deflongname>; }
                }
            }
            <.newlex(1)>
            <.regex_def_1($/)>
            [ [ ':'?'(' <signature(1)> ')'] | <trait> ]*
            <.regex_def_2($/)>
            [ <!before '{'> <.panic: "Malformed block"> ]?
            { $*IN_DECL = ''; }
            <.finishlex>
            <regex_block>:!s
            <.getsig>
            <.getdecl>
        ] || <.panic: "Malformed regex">
    }
}

augment class Metamodel::StaticSub { #OK
    method noninlinable() {
        loop (my $c = self; $c && $c.unit === $*unit; $c = $c.outer) {
            $c.strong_used = True;
        }
    }
}

augment class NieczaGrammar::P6 { #OK
    method unitstart() {
        my $top = $*unit.setting_ref;
        my $rtop = $top && $*unit.deref($top);
        $*CURLEX{'!sub'} = ::Metamodel::StaticSub.new(
            unit => $*unit,
            outerx => $top,
            cur_pkg => ['GLOBAL'],
            name => "mainline",
            run_once => !$rtop || $rtop.run_once);
        $*CURLEX{'!sub'}.add_my_name('$_') if !$top;
        $*CURLEX{'!sub'}.add_hint('$?FILE');
        $*CURLEX{'!sub'}.signature = Sig.simple();
        $*unit.mainline = $*CURLEX<!sub>;

        %*LANG<Q> = ::NieczaGrammar::Q ;
        %*LANG<MAIN> = ::NieczaGrammar::P6 ;
        self;
    }
}

augment class NieczaActions {
method type_declarator:enum ($/) {
    my $scope = $*SCOPE;
    if $scope && $scope ne 'our' && $scope ne 'my' && $scope ne 'anon' {
        $/.CURSOR.sorry("Invalid enum scope $scope");
        $scope = 'anon';
    }

    my @exports;
    for map *.ast, @$<trait> -> $t {
        if $t<export> {
            push @exports, @( $t<export> );
        } else {
            $/.CURSOR.sorry("Unsupported enum trait $t.keys()");
        }
    }

    my @pairs = self.trivial_eval($/, $<term>.ast);
    my $last = -1;
    my ($has_ints, $has_strs);
    for @pairs {
        if $_ !~~ Pair {
            my $key = $_;
            my $value = $last.succ;
            $_ = $key => $value;
        }
        given $last = .value {
            when Int { $has_ints = True; }
            when Str { $has_strs = True; }
            default  { $/.CURSOR.sorry("Enum values must be Int or Str"); }
        }
    }
    if $has_ints && $has_strs {
        $/.CURSOR.sorry("Enum may not contain both Int and Str values");
    }

    my $basetype = $*OFTYPE ?? self.simple_longname($*OFTYPE<longname>) !!
        [ 'MY', $has_strs ?? 'Str' !! 'Int' ];

    if $<name> && $<name>.reduced eq 'longname'&& ($scope ||= 'our') ne 'anon' {
        # Longnamed enum is a kind of type definition

        my $ourpath = Array;
        my $lexvar = self.gensym;
        my $bindlex = False;
        my $r = self.mangle_longname($<longname>[0], True);
        my $name = $r<name>;
        if ($r<path>:exists) && $scope ne 'our' {
            $/.CURSOR.sorry("Enum name $<longname> requires our scope");
            $scope = 'our';
        }

        if $scope eq 'our' {
            $ourpath = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            if !($r<path>:exists) {
                $lexvar  = $name;
                $bindlex = True;
            }
        } elsif $scope eq 'my' {
            $lexvar  = $name;
            $bindlex = True;
        }

        my @ns = $ourpath ?? (@( $*CURLEX<!sub>.find_pkg($ourpath) ), $name) !!
            $*unit.anon_stash;
        $*unit.create_stash([@ns]);
        $*CURLEX<!sub>.add_my_stash($lexvar, [@ns]);
        my $obj  = ::Metamodel::Class.new(:$name);
        $obj.exports = [ [@ns] ];
        $*unit.bind_item([@ns], $obj.xref);

        $obj.add_super($*unit.get_item($*CURLEX<!sub>.find_pkg(
            ['MY', ($has_strs ?? 'Str' !! 'Int') ~ "BasedEnum"])));
        $obj.add_super($*unit.get_item($*CURLEX<!sub>.find_pkg($basetype)));

        my $nb = ::Metamodel::StaticSub.new(
            transparent=> True,
            unit       => $*unit,
            outerx     => $*CURLEX<!sub>.xref,
            name       => $name,
            cur_pkg    => $*CURLEX<!sub>.cur_pkg,
            class      => 'Method',
            signature  => Sig.simple('self'),
            code       => self.init_constant(
                self.make_constant($/, 'anon', Any, Any),
                ::Op::CallMethod.new(name => 'new',
                    receiver => mklex($/, 'EnumMap'), args => [$<term>.ast])));

        $nb.add_my_name('self', noinit => True);
        $*CURLEX<!sub>.create_static_pad;
        $nb.strong_used = True;
        $*CURLEX<!sub>.add_my_sub($lexvar ~ '!enums', $nb);
        $obj.add_method('only', 'normal', 'enums', $lexvar ~ '!enums', $nb.xref);
        $obj.close;

        for @pairs {
            self.make_constant_into($/, @ns, .key, rhs =>
                ::Op::CallSub.new(invocant => mklex($/, $lexvar),
                    args => [ ::Op::StringLiteral.new(text => .key) ]));
        }

        for @pairs {
            self.init_constant(self.make_constant($/, $scope, .key, Any),
                ::Op::CallSub.new(invocant => mklex($/, $lexvar),
                    args => [ ::Op::StringLiteral.new(text => .key) ]));
        }

        make mklex($/, $lexvar);
    } else {
        make self.init_constant(
            self.make_constant($/, $<name> ?? $scope !! 'anon', ~$<name>, Any),
            ::Op::CallMethod.new(|node($/), name => 'new',
                receiver => mklex($/, 'EnumMap'),
                args => [$<term>.ast])),
    }
}
method open_package_def($, $/ = $*cursor) {
    my %_decl2mclass = (
        package => ::Metamodel::Package,
        class   => ::Metamodel::Class,
        module  => ::Metamodel::Module,
        grammar => ::Metamodel::Grammar,
        role    => ::Metamodel::Role,
    );
    my $sub = $*CURLEX<!sub>;

    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }

    my $scope = $*SCOPE;
    if !$<longname> {
        $scope = 'anon';
    }

    if $scope eq 'supersede' {
        $/.CURSOR.sorry('Supercede is not yet supported');
        $scope = 'our';
    }
    if $scope eq 'has' || $scope eq 'state' {
        $/.CURSOR.sorry("Illogical scope $scope for package block");
        $scope = 'our';
    }

    if $scope eq 'augment' {
        my $r = self.mangle_longname($<longname>[0], True);
        my $name = $r<name>;
        my @augpkg = @( $r<path> // ['MY'] );

        my $pkg = $sub.outer.find_pkg([ @augpkg, $name ]);
        my $so  = $*unit.get_item($pkg);
        my $dso = $*unit.deref($so);

        if $dso.^isa(::Metamodel::Role) {
            $/.CURSOR.panic("Illegal augment of a role");
        }

        my @ah = $so;
        $sub.augment_hack = @ah;
        $sub.body_of = $sub.in_class = $so;
        $sub.augmenting = True;
        $sub.set_name("augment-$dso.name()");
    } else {
        my ($name, $ourpkg);
        my $type = %_decl2mclass{$*PKGDECL};
        if ($*PKGDECL//'role') eq 'role' && $<signature> {
            $sub.signature = $<signature>.ast;
            $type = ::Metamodel::ParametricRole;
        }
        my @ns;
        if $<longname> {
            my $r = self.mangle_longname($<longname>[0], True);
            $name = $r<name>;
            if ($r<path>:exists) && $scope ne 'our' {
                $/.CURSOR.sorry("Block name $<longname> requires our scope");
                $scope = 'our';
            }
            if $scope eq 'our' {
                $ourpkg = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            }
            if !$r<path> && ($*CURLEX<!sub>.outer.lexicals.{$r<name>} ~~ ::Metamodel::Lexical::Stash) {
                @ns = @( $*CURLEX<!sub>.outer.find_pkg(['MY',$r<name>]) );
            }
            $*CURLEX<!sub>.outervar = ($scope eq 'anon' || ($r<path>:exists))
                ?? self.gensym !! $name;
        } else {
            $*CURLEX<!sub>.outervar = self.gensym;
            $name = 'ANON';
        }

        my $old = @ns ?? $*unit.get_item([@ns]) !! Any;

        if $old && ($old.[0] ne $*unit.name || $*unit.deref($old).closed) {
            $/.CURSOR.panic("Redefinition of class [@ns]");
        }
        my $obj;
        if $old {
            $obj = $*unit.deref($old);
        } else {
            @ns = $ourpkg ?? (@( $sub.outer.find_pkg($ourpkg) ), $name) !!
                $*unit.anon_stash;

            $*unit.create_stash([@ns]);

            $sub.outer.add_my_stash($*CURLEX<!sub>.outervar, [@ns]);
            $obj = $type.new(:$name);
            $obj.exports = [ [@ns] ];
            $*unit.bind_item([@ns], $obj.xref);
        }

        $sub.body_of = $sub.in_class = $obj.xref;
        $sub.cur_pkg = [@ns];

        self.process_block_traits($/, $<trait>);
        $sub.set_name($*PKGDECL ~ "-" ~ $obj.name);
    }
}

method process_block_traits($/, @tr) {
    my $sub = $*CURLEX<!sub>;
    my $pack = $sub.body_of;
    for map *.ast, @tr -> $tr {
        if $pack && ($tr<name>:exists) {
            my ($name, $path) = $tr<name path>;

            $/.CURSOR.sorry("superclass $name declared outside of any class"),
                next unless $sub.body_of;
            $/.CURSOR.sorry("superclass $name declared in an augment"),
                next if $sub.augmenting;

            $*unit.deref($pack).add_super($*unit.get_item($sub.find_pkg(
                [ @($path // ['MY']), $name ])));
        } elsif $pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_pkg_exports($*unit, $*unit.deref($pack).name,
                $sub.cur_pkg, @exports);
        } elsif !$pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_exports($*unit, '&' ~ $sub.name, @exports);
            $sub.strong_used = True;
            $sub.outer.create_static_pad;
            $sub.exports //= [];
            push $sub.exports, [ @($sub.outer.find_pkg(
                ['OUR','EXPORT',$_])), '&' ~ $sub.name ] for @exports;
        } elsif !$pack && $tr<nobinder> {
            $sub.signature = Any;
        } elsif !$pack && $tr<return_pass> {
            $sub.returnable = False;
        } elsif !$pack && $tr<of> {
        } elsif !$pack && $tr<rw> {
        } elsif !$pack && $tr<unsafe> {
            $sub.unsafe = True;
        } else {
            $/.CURSOR.sorry("Unhandled trait $tr.keys[0] for this context");
        }
    }
}

method package_def ($/) {
    my $sub = $*CURLEX<!sub>;

    my $bodyvar = self.gensym;
    $sub.outer.add_my_sub_child($bodyvar, $sub);
    $sub.code = ($<blockoid> // $<statementlist>).ast;

    if $sub.augmenting {
        my $ah = $sub.augment_hack;
        $sub.augment_hack = Any;

        my $ph = ::Metamodel::StaticSub.new(
            unit       => $*unit,
            outerx     => $sub.xref,
            cur_pkg    => [ 'GLOBAL' ],
            name       => 'ANON',
            is_phaser  => 0,
            augment_hack => $ah,
            class      => 'Code',
            code       => ::Op::StatementList.new(children => []),
            run_once   => $sub.run_once);
        $sub.create_static_pad;
        $sub.add_child($ph);

        make ::Op::CallSub.new(|node($/), invocant => mklex($/, $bodyvar));
    }
    else {
        my $obj = $*unit.deref($sub.body_of);

        if $*DECLARAND<stub> {
            push $*unit.stubbed_stashes, ($obj => $/.CURSOR);

            make mklex($/, $*CURLEX<!sub>.outervar);
        }
        else {
            $obj.close;

            if $obj ~~ ::Metamodel::ParametricRole {
                $sub.parametric_role_hack = $obj.xref;
                $sub.add_my_name('*params', :noinit);
                $sub.create_static_pad;

                make mklex($/, $*CURLEX<!sub>.outervar);
            } else {
                make ::Op::StatementList.new(|node($/), children => [
                    ::Op::CallSub.new(invocant => mklex($/, $bodyvar)),
                    ::Op::Lexical.new(name => $*CURLEX<!sub>.outervar) ]);
            }
        }
    }
}


method thunk_sub($code, :$params = [], :$name, :$class, :$ltm) {
    my $n = ::Metamodel::StaticSub.new(
        outerx => $*CURLEX<!sub>.xref,
        class => $class // 'Block',
        unit => $*unit,
        name => $name // 'ANON',
        transparent => True,
        code => $code,
        ltm => $ltm,
        in_class => $*CURLEX<!sub>.in_class,
        cur_pkg => $*CURLEX<!sub>.cur_pkg);
    $n.signature = Sig.simple(@$params);
    $n.add_my_name($_, :noinit) for @$params;
    $n.add_my_name('$*/') if $class eq 'Regex';
    $*CURLEX<!sub>.add_child($n);
    $n;
}

method type_declarator:subset ($/) {
    my $ourname = Array; my $lexvar = self.gensym; my $name;
    my $scope = $*SCOPE;
    if $scope && $scope ne 'our' && $scope ne 'my' && $scope ne 'anon' {
        $/.CURSOR.sorry("Invalid subset scope $scope");
        $scope = 'anon';
    }
    if $<longname> {
        $scope ||= 'my';
        my $r = self.mangle_longname($<longname>[0], True);
        $name = $r<name>;
        if ($r<path>:exists) && $scope ne 'our' {
            $/.CURSOR.sorry("Block name $<longname> requires our scope");
            $scope = 'our';
        }
        if $scope eq 'our' {
            $ourname = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            $ourname = [ @$ourname, $name ];
        } elsif $scope eq 'my' {
            $lexvar  = $name;
        }
    } else {
        if ($scope || 'anon') ne 'anon' {
            $/.CURSOR.sorry("Cannot have a non-anon subset with no name");
        }
        $name = 'ANON';
    }

    my $basetype = $*OFTYPE ?? self.simple_longname($*OFTYPE<longname>) !!
        ['MY', 'Any'];
    my @exports;

    for map *.ast, @$<trait> -> $t {
        if $t<export> {
            push @exports, @( $t<export> );
        } elsif $t<of> {
            $basetype = $t<of>;
        } else {
            $/.CURSOR.sorry("Unsupported subset trait $t.keys()");
        }
    }

    my $body = self.thunk_sub($<EXPR> ?? $<EXPR>[0].ast !! mklex($/, 'True'));

    my @ns = $ourname ?? @( $*CURLEX<!sub>.find_pkg($ourname) ) !!
        $*unit.anon_stash;

    $*unit.create_stash([@ns]);
    $*CURLEX<!sub>.add_my_stash($lexvar, [@ns]);
    $*CURLEX<!sub>.add_pkg_exports($*unit, $name, [@ns], @exports);
    $*CURLEX<!sub>.create_static_pad;

    $basetype = $*unit.get_item($*CURLEX<!sub>.find_pkg([@$basetype]));
    my $obj = ::Metamodel::Subset.new(:$name, where => $body.xref, :$basetype);
    $*unit.bind_item([@ns], $obj.xref);
    $obj.exports = [ [@ns] ];

    make mklex($/, $lexvar);
}

method encapsulate_regex($/, $rxop, :$goal, :$passcut = False,
        :$passcap = False) {
    my @lift = $rxop.oplift;
    my $lad = $rxop.lad;
    my ($nrxop, $mb) = OptRxSimple.run($rxop);
    if defined $goal {
        unshift @lift, ::Op::Bind.new(|node($/), readonly => True,
            lhs => mklex($/, '$*GOAL'),
            rhs => ::Op::StringLiteral.new(text => $goal));
    }
    my $subop = self.thunk_sub(
        ::Op::RegexBody.new(canback => $mb, pre => @lift, :$passcut, :$passcap,
            rxop => $nrxop), ltm => $lad, class => 'Regex', params => ['self']);
    $subop.add_my_name('$*GOAL') if defined($goal);
    $subop = ::Op::CallSub.new(|node($/), invocant => self.block_expr($/, $subop),
        positionals => [ ::Op::MakeCursor.new(|node($/)) ]);
    ::RxOp::Subrule.new(regex => $subop, :$passcap, _passcapzyg => $nrxop,
        _passcapltm => $lad);
}
method regex_def_1 ($, $/ = $*cursor) {
    sub _symtext($name) {
        ($name ~~ /\:sym\<(.*)\>/) ?? ($name.substr(0, $/.from), ~$0) !!
            ($name ~~ /\:(\w+)/) ?? ($name.substr(0, $/.from), ~$0) !!
            ($name, Str);
    }

    my ($m,$p) = $<deflongname> ??
        self.mangle_longname($<deflongname>).<name path> !! ();
    my $multiness = $*MULTINESS || 'only';

    $*CURLEX<!name> = $m;
    if $m ~~ Op {
        $*CURLEX<!name> = $*CURLEX<!cleanname> = '::($name)';
    } elsif defined $m {
        $*CURLEX<!cleanname !sym> = _symtext($m);
        $multiness = 'multi' if defined $*CURLEX<!sym>;
    }
    $*CURLEX<!multi> = $multiness;

    self.install_sub($/, $*CURLEX<!sub>, scope => $*SCOPE, name => $m,
        method_type => (($*SCOPE || 'has') eq 'has') ?? 'normal' !! Any,
        path => $p, :$multiness, class => 'Regex');
}

method install_sub($/, $sub, :$multiness is copy, :$scope is copy, :$class,
        :$path, :$name is copy, :$method_type is copy, :$contextual is copy) {

    $multiness ||= 'only';
    $path := Any if $name ~~ Op; #Hack

    if !$scope {
        if !defined($name) {
            $scope = 'anon';
        } elsif defined($path) {
            $scope = 'our';
        } elsif defined($method_type) {
            $scope = 'has';
        } else {
            $scope = 'my';
        }
    }

    if $scope ne 'my' && $scope ne 'our' && $scope ne 'anon' && $scope ne 'has' {
        $/.CURSOR.sorry("Illegal scope $scope for subroutine");
        $scope = 'anon';
    }

    if $scope eq 'has' && !defined($method_type) {
        $/.CURSOR.sorry('has scope-type is only valid for methods');
        $scope = 'anon';
    }

    if $scope ne 'anon' && !defined($name) {
        $/.CURSOR.sorry("Scope $scope requires a name");
        $scope = 'anon';
    }

    if $scope ne 'our' && defined($path) {
        $/.CURSOR.sorry("Double-colon-qualified subs must be our");
        $scope = 'our';
    }

    if $scope eq 'anon' && $multiness ne 'only' {
        $/.CURSOR.sorry("Multi routines must have a name");
        $multiness = 'only';
    }

    if $contextual && (defined($method_type) || $scope ne 'my') {
        $/.CURSOR.sorry("Context-named routines must by purely my-scoped");
        $contextual = False;
    }

    $method_type = Str if $scope eq 'anon';

    my $method_targ = $method_type && $sub.outer.body_of;
    if $method_targ {
        $method_targ = $*unit.deref($method_targ);
    } elsif defined($method_type) {
        $/.CURSOR.sorry("Methods must be used in some kind of package");
        $method_type = Str;
    }

    if $name ~~ Op && (!defined($method_type) || $scope ne 'has' ||
            $method_targ !~~ ::Metamodel::ParametricRole) {
        $/.CURSOR.sorry("Computed names are only implemented for parametric roles");
        $name = "placeholder";
    }

    my $bindlex = $scope eq 'my' || ($scope eq 'our' && !$path);

    $sub.set_name(($name ~~ Op) ?? '::($name)' !!
        defined($method_type) ?? $method_targ.name ~ "." ~ $name !!
        ($name // 'ANON'));
    $sub.class = $class;
    $sub.returnable = True;

    my Str $symbol;
    if $bindlex && $class eq 'Regex' {
        $symbol = '&' ~ $name;
        my $proto = $symbol;
        $proto ~~ s/\:.*//;
        $sub.outer.add_dispatcher($proto) if $multiness ne 'only'
            && !$sub.outer.lexicals.{$proto};
        $symbol ~= ":(!proto)" if $multiness eq 'proto';
    } elsif $bindlex {
        $symbol = '&' ~ $name;
        $sub.outer.add_dispatcher($symbol) if $multiness ne 'only'
            && !$sub.outer.lexicals.{$symbol};

        given $multiness {
            when 'multi' { $symbol ~= ":({ self.gensym })"; }
            when 'proto' { $symbol ~= ":(!proto)"; }
        }
    } else {
        $symbol = self.gensym;
    }

    $sub.outervar = $symbol;
    $sub.methodof = defined($method_type) ?? $method_targ.xref !! Any;
    $sub.outer.add_my_sub_child($symbol, $sub);

    if defined($method_type) || $scope eq 'our' {
        $sub.strong_used = True;
        $sub.outer.create_static_pad;
    }

    if defined($method_type) {
        if $sub.outer.augment_hack {
            push $sub.outer.augment_hack,
                [ $multiness, $method_type, $name, $symbol, $sub.xref ];
        } else {
            $method_targ.add_method($multiness, $method_type, $name,
                $symbol, $sub.xref);
        }
    }

    if $scope eq 'our' {
        $sub.exports = [[@($sub.outer.find_pkg($path // ['OUR'])), '&'~$name]];
    }
}
method regex_def_2 ($, $/ = $*cursor) {
    if $<signature> > 1 {
        $/.CURSOR.sorry("Too many signatures on regex");
    }
}



method regex_def($/) {
    my $endsym;
    for map *.ast, @$<trait> -> $t {
        if $t<unary> || $t<binary> || $t<defequiv> || $t<of> {
            # Ignored for now
        }
        elsif defined $t<endsym> {
            $endsym = $t<endsym>;
        }
        else {
            $/.CURSOR.sorry("Unhandled regex trait $t.keys.[0]");
        }
    }

    if $*CURLEX<!multi> eq 'proto' {
        if ($<signature> && $<signature>[0].ast.params != 1) ||
                !$<regex_block><onlystar> {
            $/.CURSOR.sorry('Only {*} protoregexes with no parameters are supported');
        }
        @*MEMOS[0]<proto_endsym>{$*CURLEX<!cleanname>} = $endsym
            if defined $*CURLEX<!cleanname>;
    } else {
        $endsym //= @*MEMOS[0]<proto_endsym>{$*CURLEX<!cleanname>} if
            defined $*CURLEX<!cleanname>;
    }

    my $ast = $<regex_block>.ast;
    if $*CURLEX<!multi> eq 'proto' {
        $ast = ::RxOp::ProtoRedis.new(name => $*CURLEX<!name>);
    }

    {
        my $*paren = 0;
        my $*symtext = $*CURLEX<!sym>;
        my $*endsym = $endsym;
        my $*dba = $*CURLEX<!name> // 'anonymous regex';
        $ast.check;
    }
    my @lift = $ast.oplift;
    $*CURLEX<!sub>.ltm = OptRxSimple.run_lad($ast.lad);
    ($ast, my $mb) = OptRxSimple.run($ast);
    $*CURLEX<!sub>.add_my_name('$*/');
    $*CURLEX<!sub>.code = ::Op::RegexBody.new(|node($/), pre => @lift,
        name => ($*CURLEX<!name> // ''), rxop => $ast, canback => $mb);
    make mklex($/, $*CURLEX<!sub>.outervar);
}

method signature($/) {
    if $<type_constraint> {
        # ignore for now
    }

    if $<param_var> {
        my $sig = Sig.new(params => [ ::Sig::Parameter.new(
                name => ~$<param_var>, |$<param_var>.ast,
                full_parcel => True) ]);
        $*CURLEX<!sub>.signature = $sig if $*SIGNUM;
        make $sig;
        return;
    }

    my @p = map *.ast, @( $<parameter> );
    my @ps = @( $<param_sep> );
    my $ign = False;
    loop (my $i = 0; $i < @p; $i++) {
        @p[$i].multi_ignored = $ign;
        if $i >= @ps {
        } elsif defined @ps[$i].index(':') {
            $/.CURSOR.sorry('Only the first parameter may be invocant') if $i;
            $*CURLEX<!sub>.add_my_name('self', :noinit);
            @p[$i].invocant = True;
        } elsif defined @ps[$i].index(';;') {
            $ign = True;
        } elsif !defined @ps[$i].index(',') {
            $/.CURSOR.sorry("Parameter separator @ps[$i] NYI");
        }
    }

    state %mlike = (:Method, :Submethod, :Regex);
    if $*SIGNUM && %mlike{$*CURLEX<!sub>.class} && (!@p || !@p[0].invocant) {
        $*CURLEX<!sub>.add_my_name('self', :noinit);
        unshift @p, ::Sig::Parameter.new(name => 'self', :invocant);
    }

    for @p {
        if !defined(.tclass) && $*SIGNUM {
            if .invocant && $*CURLEX<!sub>.methodof {
                my $cl = $*unit.deref($*CURLEX<!sub>.methodof);
                # XXX type checking against roles NYI
                if $cl !~~ ::Metamodel::Role &&
                        $cl !~~ ::Metamodel::ParametricRole {
                    .tclass = $cl.xref;
                }
            } elsif !$*CURLEX<!sub>.returnable {
                .tclass = $*unit.get_item($*CURLEX<!sub>.find_pkg(['MY','Mu']));
            }
        }
    }

    my $sig = Sig.new(params => @p);
    $*CURLEX<!sub>.signature = $sig if $*SIGNUM;
    make $sig;
}

method embeddedblock($/) {
    $*CURLEX<!sub>.code = $<statementlist>.ast;
    $*CURLEX<!sub>.signature = Sig.simple();
    make $*CURLEX<!sub>;
}
method metachar:sym<{ }> ($/) {
    $<embeddedblock>.ast.signature = Sig.simple('$¢');
    $<embeddedblock>.ast.add_my_name('$¢', :noinit);

    make ::RxOp::VoidBlock.new(block => self.inliney_call($/,
        $<embeddedblock>.ast, ::Op::MakeCursor.new(|node($/))));
}
method assertion:sym<{ }> ($/) {
    $<embeddedblock>.ast.signature = Sig.simple('$¢');
    $<embeddedblock>.ast.add_my_name('$¢', :noinit);

    make ::RxOp::CheckBlock.new(block => self.inliney_call($/,
        $<embeddedblock>.ast, ::Op::MakeCursor.new(|node($/))));
}
method escape:sym<{ }> ($/) { make self.inliney_call($/, $<embeddedblock>.ast) }

method quantifier:sym<**> ($/) {
    # XXX can't handle normspace well since it's not labelled 1*/2*
    my $h = $<embeddedblock> ?? { min => 0, cond =>
                self.inliney_call($/, $<embeddedblock>.ast) } !!
            $<quantified_atom> ?? { min => 1, sep => $<quantified_atom>.ast } !!
            { min => +~$0, max => ($1 ?? +~$1 !!
                defined($/.index('..')) ?? Any !! +~$0) };
    $h<mod> = $<quantmod>.ast;
    make $h;
}
method statement_control:use ($/) {
    make ::Op::StatementList.new;
    return if $<version>; # just ignore these

    my $name = $<module_name>.ast<name>;
    my $args = $<arglist> ?? $<arglist>.ast !! [];

    if defined $<module_name>.ast.<args> {
        $/.CURSOR.sorry("'use' of an instantiated role not yet understood");
        return;
    }

    if $args {
        $/.CURSOR.sorry("'use' with arguments NYI");
        return;
    }

    if ($name eq 'MONKEY_TYPING' || $name eq 'fatal' || $name eq 'lib') {
        return;
    }

    my $u2 = $*unit.need_unit($name);

    my @can = @( $u2.mainline.find_pkg([$name.split('::')]) );
    my @exp = (@can, 'EXPORT', 'DEFAULT');

    # XXX I am not sure how need binding should work in the :: case
    if $name !~~ /"::"/ {
        $*CURLEX<!sub>.lexicals{$name} =
            ::Metamodel::Lexical::Stash.new(path => @can);
    }

    for $*unit.list_stash(@exp) -> $tup {
        my $uname = $tup[0];
        my $lex;
        if $tup[1] eq 'var' {
            if $tup[2] && !$tup[2][0] {
                $lex = ::Metamodel::Lexical::Common.new(path => @exp, name => $uname);
            } elsif $tup[2] {
                $lex = ::Metamodel::Lexical::Stash.new(path => [@exp, $uname]);
            }
        } elsif $tup[1] eq 'graft' {
            $lex = ::Metamodel::Lexical::Stash.new(path => $tup[2]);
        } else {
            die "weird return";
        }

        $*CURLEX<!sub>.lexicals{$uname} = $lex;
    }
}
method param_var($/) {
    if $<signature> {
        $/.CURSOR.sorry('Sub-signatures NYI');
        make { };
        return Nil;
    }
    my $twigil = $<twigil> ?? ~$<twigil>[0] !! '';
    my $sigil =  ~$<sigil>;
    my $list = $sigil eq '@';
    my $hash = $sigil eq '%';
    my $name =   $<name> ?? ~$<name>[0] !! Any;
    $twigil = '*' if $name && ($name eq '/' || $name eq '!');

    my $slot;
    if $twigil eq '' {
        $slot = defined($name) ?? ($sigil ~ $name) !! Any;
    } elsif $twigil eq '*' {
        $slot = "$sigil*" ~ "$name";
    } else {
        $/.CURSOR.sorry("Unhandled parameter twigil $twigil");
        make { };
        return Nil;
    }

    if ($sigil ne '$' && $sigil ne '@' && $sigil ne '%' && $sigil ne '&') {
        $/.CURSOR.sorry('Non bare scalar targets NYI');
        make { }
        return Nil;
    }

    $*CURLEX<!sub>.add_my_name($slot, :$list, :$hash, noinit => ?($*SIGNUM))
        if defined($slot);

    make { :$list, :$hash, :$slot,
        names => defined($name) ?? [ $name ] !! [] }
}

}

augment class Op::ForLoop { #OK
    method statement_level() {
        my $body = $*CURLEX<!sub>.find_lex($!sink.symbol).body;
        my $var = [ map { ::GLOBAL::NieczaActions.gensym },
            0 ..^ +$body.signature.params ];
        $!sink.once = True;
        ::Op::ImmedForLoop.new(source => $!source, var => $var,
            sink => ::Op::CallSub.new(invocant => $!sink,
                positionals => [ map { ::Op::LetVar.new(name => $_) }, @$var]));
    }
}

augment class Sig::Parameter { #OK
    method bind_inline($body, @posr) {
        my $get = $!full_parcel ?? self.parcel_get_inline(@posr) !!
            $!slurpycap ?? self.slurpycap_get_inline(@posr) !!
            $!slurpy ?? self.slurpy_get_inline(@posr) !!
            self.single_get_inline($body, @posr);

        if (defined $!slot) {
            if $!is_copy {
                self.do_copy($get);
            } else {
                my $type = CgOp.class_ref('mo', @($!tclass || 'Any'));
                CgOp.scopedlex($!slot, $!rwtrans ?? $get !!
                    CgOp.newboundvar(+(!$!rw), +$!list, $type, $get));
            }
        } else {
            CgOp.sink($get);
        }
    }
}

augment class Operator::Temp { #OK
    method with_args($/, *@args) {
        my $rarg = @args[0];
        if !$rarg.^isa(::Op::ContextVar) || $rarg.uplevel {
            $/.CURSOR.sorry('Non-contextual case of temp NYI');
            return ::Op::StatementList.new;
        }
        my $hash = substr($rarg.name,0,1) eq '%';
        my $list = substr($rarg.name,0,1) eq '@';
        $*CURLEX<!sub>.add_my_name($rarg.name, :$hash, :$list);
        mkcall($/, '&infix:<=>',
            ::Op::Lexical.new(name => $rarg.name, :$hash, :$list),
            ::Op::ContextVar.new(name => $rarg.name, uplevel => 1));
    }
}

class Op::MakeJunction is Op {
    has Int $.typecode = die "MakeJunction.typecode required";
    has @.zyg;

    method code($body) {
        CgOp.makejunction($!typecode, map *.cgop($body), @!zyg)
    }
}

CgOp._register_ops: < makejunction
>;

augment class Op::BareBlock { #OK
    method statement_level() {
        # This cheat relies on the fact that we can't have any lexicals put
        # into this block until after the compile is done, so the usual
        # issues with changing lexical representation don't apply :)
        my $body = $*CURLEX<!sub>.find_lex($!var).body;
        if $body.code ~~ ::Op::YouAreHere {
            $body.run_once = $body.outer.run_once;
        }

        ::Op::CallSub.new(invocant => ::Op::SubDef.new(body => Any, :once,
            symbol => $!var));
    }
}

augment class Operator {
method wrap_in_function($/) {
    my @args;
    my $i = -self.arity;
    while $i++ { push @args, ::GLOBAL::NieczaActions.gensym }
    my $do = self.with_args($/, map { mklex($/, $_) }, @args);
    ::GLOBAL::NieczaActions.block_expr($/,
        ::GLOBAL::NieczaActions.thunk_sub($do, params => @args));
}
}

augment class Operator::PostCall { #OK
    method as_function($/) { self.wrap_in_function($/) }
}


my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
elsif $bcnd eq 'hoopl' {
    $backend = NieczaBackendHoopl.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $stages;
if $bcnd eq 'clisp' {
    $stages = [
        NieczaPassSimplifier.new,
    ];
} elsif $bcnd eq 'hoopl' {
    $stages = [
        NieczaPassSimplifier.new,
    ];
} else {
    $stages = [
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ];
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => $stages,
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    my $*repl_outer;
    $c.compile_string('', !$comp, $stop);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, $stop, :repl, :evalmode,
                :outer($*repl_outer));
            $ok = True;
        }
        say $! unless $ok;
    }
}
